#version 450

layout(location = 0) out vec4 outColor;

layout(binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
    mat4 viewProj;
    vec3 viewPos;
    float time;
    vec3 lightDir;
    float padding;
} ubo;

layout(push_constant) uniform PushConstants {
    vec2 resolution;
    float planetRadius;
    int debugMode;
} pc;

struct OctreeNode {
    vec4 centerAndSize;
    uvec4 childrenAndFlags;
};

layout(std430, binding = 1) readonly buffer NodeBuffer {
    OctreeNode nodes[];
} nodeBuffer;

// Material table - 16 materials with color and properties
struct Material {
    vec4 color;  // RGB color + alpha/reserved
    vec4 properties;  // density, state, reserved, reserved
};

layout(std430, binding = 2) readonly buffer MaterialTable {
    Material materials[16];
} materialTable;

// Shared implementation that works in both C and GLSL
vec2 raySphere(vec3 origin, vec3 dir, vec3 center, float radius) {
    vec3 oc;
    oc.x = origin.x - center.x;
    oc.y = origin.y - center.y;
    oc.z = origin.z - center.z;
    
    float b = dot(oc, dir);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    
    vec2 result;
    if (h < 0.0) {
        result.x = -1.0;
        result.y = -1.0;
    } else {
        h = sqrt(h);
        result.x = -b - h;
        result.y = -b + h;
    }
    return result;
}

vec4 traverseOctree(vec3 rayOrigin, vec3 rayDir) {
    vec4 blackSpace;
    blackSpace.x = 0.0; blackSpace.y = 0.0; 
    blackSpace.z = 0.0; blackSpace.w = 1.0;
    
    // Debug mode 1: Red sphere test
    if (pc.debugMode == 1) {
        vec3 center; 
        center.x = 0.0; center.y = 0.0; center.z = 0.0;
        vec2 hit = raySphere(rayOrigin, rayDir, center, pc.planetRadius);
        if (hit.x > 0.0) {
            vec4 red;
            red.x = 1.0; red.y = 0.0; red.z = 0.0; red.w = 1.0;
            return red;
        }
        return blackSpace;
    }
    
    // Check planet intersection
    vec3 planetCenter;
    planetCenter.x = 0.0; planetCenter.y = 0.0; planetCenter.z = 0.0;
    vec2 planetHit = raySphere(rayOrigin, rayDir, planetCenter, pc.planetRadius);
    
    if (planetHit.x < 0.0) {
        return blackSpace;
    }
    
    // Calculate ray start position
    float startDist = max(planetHit.x, 0.0);
    vec3 rayStart;
    rayStart.x = rayOrigin.x + rayDir.x * startDist;
    rayStart.y = rayOrigin.y + rayDir.y * startDist;
    rayStart.z = rayOrigin.z + rayDir.z * startDist;
    
    // Traversal constants
    const int MAX_STEPS = 400;
    const float MIN_STEP = 10.0;  // Reduced from 100.0 to avoid gaps
    float MAX_DISTANCE = pc.planetRadius * 2.0;
    
    float t = 0.0;
    vec3 currentPos = rayStart;
    
    // Main traversal loop
    for (int step = 0; step < MAX_STEPS; step++) {
        // Update position
        currentPos.x = rayStart.x + rayDir.x * t;
        currentPos.y = rayStart.y + rayDir.y * t;
        currentPos.z = rayStart.z + rayDir.z * t;
        
        // Check if we've left the planet
        float distFromCenter = length(currentPos);
        if (distFromCenter > pc.planetRadius || t > MAX_DISTANCE) {
            break;
        }
        
        // Traverse octree from root
        uint nodeIndex = 0;
        float currentNodeSize = nodeBuffer.nodes[0].centerAndSize.w;
        
        // Traverse down to leaf (max 15 levels)
        for (int depth = 0; depth < 15; depth++) {
            OctreeNode node = nodeBuffer.nodes[nodeIndex];
            
            // Check if this is a leaf
            bool isLeaf = (node.childrenAndFlags.z & 1u) != 0u;
            
            if (isLeaf) {
                // Extract material type (stored as dominant material ID)
                uint materialId = (node.childrenAndFlags.z >> 8) & 0xFFu;
                
                // Material IDs: 0=Vacuum, 1=Air, 2=Rock, 3=Water, etc.
                // Skip vacuum (0) and air (1) materials
                if (materialId > 1u && materialId < 16u) {
                    // Get color from material table
                    vec4 color = materialTable.materials[materialId].color;
                    
                    // Simple lighting
                    vec3 normal = normalize(currentPos);
                    vec3 lightDir;
                    lightDir.x = 1.0; lightDir.y = 1.0; lightDir.z = 0.5;
                    lightDir = normalize(lightDir);
                    float NdotL = max(dot(normal, lightDir), 0.0);
                    
                    color.x = color.x * (0.3 + 0.7 * NdotL);
                    color.y = color.y * (0.3 + 0.7 * NdotL);
                    color.z = color.z * (0.3 + 0.7 * NdotL);
                    
                    return color;
                }
                break; // Leaf with air, continue marching
            }
            
            // Not a leaf, find child
            uint childrenOffset = node.childrenAndFlags.x;
            if (childrenOffset == 0xFFFFFFFFu || childrenOffset >= 200000u) {
                break; // Invalid children
            }
            
            // Calculate octant
            vec3 nodeCenter;
            nodeCenter.x = node.centerAndSize.x;
            nodeCenter.y = node.centerAndSize.y;
            nodeCenter.z = node.centerAndSize.z;
            
            uint octant = 0u;
            if (currentPos.x > nodeCenter.x) octant |= 1u;
            if (currentPos.y > nodeCenter.y) octant |= 2u;
            if (currentPos.z > nodeCenter.z) octant |= 4u;
            
            // Move to child node
            nodeIndex = childrenOffset + octant;
            currentNodeSize = currentNodeSize * 0.5;
            
            // Bounds check
            if (nodeIndex >= 200000u) {
                break;
            }
        }
        
        // Step forward with smaller steps to avoid gaps
        float stepSize = max(MIN_STEP, currentNodeSize * 0.25);  // Reduced from 0.5 to 0.25
        t = t + stepSize;
    }
    
    return blackSpace;
}

void main() {
    vec2 uv = (gl_FragCoord.xy / pc.resolution) * 2.0 - 1.0;
    uv.y = -uv.y;
    
    vec3 rayOrigin = ubo.viewPos;
    
    mat4 invViewProj = inverse(ubo.viewProj);
    vec4 nearPoint = invViewProj * vec4(uv, 0.0, 1.0);
    vec4 farPoint = invViewProj * vec4(uv, 1.0, 1.0);
    nearPoint /= nearPoint.w;
    farPoint /= farPoint.w;
    
    vec3 rayDir = normalize(farPoint.xyz - rayOrigin);
    
    outColor = traverseOctree(rayOrigin, rayDir);
}