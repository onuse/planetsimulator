#version 450

// SIMPLIFIED mesh generator - just create one quad per surface voxel
// This lets us verify the pipeline before implementing full Transvoxel

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

// Octree node structure
struct OctreeNode {
    vec4 centerAndSize;      // xyz = center, w = halfSize
    uvec4 childrenAndFlags;  // x = children offset, y = voxel offset, z = flags, w = reserved
};

// Vertex structure matching the pipeline
struct Vertex {
    vec3 position;
    vec3 color;     // Note: color comes before normal to match shader
    vec3 normal;
    vec2 texCoord;
};

// Input: Octree nodes
layout(binding = 0, std430) readonly buffer OctreeBuffer {
    OctreeNode nodes[];
} octree;

// Output: Vertices
layout(binding = 1, std430) writeonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

// Output: Indices
layout(binding = 2, std430) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

// Output: Counters
layout(binding = 3, std430) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
} counter;

const uint MAX_VERTICES = 1000000;
const uint MAX_INDICES = 3000000;
const float PLANET_RADIUS = 1000.0;

// Check if node is a leaf
bool isLeaf(OctreeNode node) {
    return (node.childrenAndFlags.z & 1u) != 0u;
}

// Get material from flags
uint getMaterial(OctreeNode node) {
    return (node.childrenAndFlags.z >> 8u) & 0xFFu;
}

// Get color for material
vec3 getMaterialColor(uint mat) {
    if (mat == 1u) return vec3(0.7, 0.9, 1.0);  // Air - light blue
    if (mat == 2u) return vec3(0.5, 0.4, 0.3);  // Rock - brown  
    if (mat == 3u) return vec3(0.0, 0.3, 0.7);  // Water - blue
    return vec3(1.0, 0.0, 1.0);                  // Unknown - magenta
}

void main() {
    uint nodeIndex = gl_GlobalInvocationID.x;
    
    // Bounds check
    if (nodeIndex >= octree.nodes.length()) {
        return;
    }
    
    OctreeNode node = octree.nodes[nodeIndex];
    
    // Only process leaf nodes
    if (!isLeaf(node)) {
        return;
    }
    
    // Skip air/vacuum
    uint material = getMaterial(node);
    if (material == 0u) {
        return;
    }
    
    vec3 center = node.centerAndSize.xyz;
    float halfSize = node.centerAndSize.w;
    
    // Check if this node is near the surface
    float distFromCenter = length(center);
    if (distFromCenter < 100.0 || distFromCenter > 2000.0) {
        return; // Skip nodes that are too close to center or too far
    }
    
    // Normalize the center to get the direction from planet center
    vec3 normal = normalize(center);
    vec3 color = getMaterialColor(material);
    
    // Generate tangent vectors
    vec3 up = abs(normal.y) < 0.9 ? vec3(0, 1, 0) : vec3(0, 0, 1);
    vec3 tangent = normalize(cross(up, normal));
    vec3 bitangent = cross(normal, tangent);
    
    // Allocate 4 vertices
    uint baseVertex = atomicAdd(counter.vertexCount, 4u);
    if (baseVertex + 3 >= MAX_VERTICES) return;
    
    // Create quad vertices at the actual node position
    // The node center should already be in world space
    float size = min(halfSize, 10.0); // Cap the size to prevent huge quads
    
    // Use the actual node center position for the quad
    vec3 quadCenter = center;
    vertexBuffer.vertices[baseVertex + 0].position = quadCenter + (tangent - bitangent) * size;
    vertexBuffer.vertices[baseVertex + 0].color = color;
    vertexBuffer.vertices[baseVertex + 0].normal = normal;
    vertexBuffer.vertices[baseVertex + 0].texCoord = vec2(0, 0);
    
    vertexBuffer.vertices[baseVertex + 1].position = quadCenter + (tangent + bitangent) * size;
    vertexBuffer.vertices[baseVertex + 1].color = color;
    vertexBuffer.vertices[baseVertex + 1].normal = normal;
    vertexBuffer.vertices[baseVertex + 1].texCoord = vec2(1, 0);
    
    vertexBuffer.vertices[baseVertex + 2].position = quadCenter + (-tangent + bitangent) * size;
    vertexBuffer.vertices[baseVertex + 2].color = color;
    vertexBuffer.vertices[baseVertex + 2].normal = normal;
    vertexBuffer.vertices[baseVertex + 2].texCoord = vec2(1, 1);
    
    vertexBuffer.vertices[baseVertex + 3].position = quadCenter + (-tangent - bitangent) * size;
    vertexBuffer.vertices[baseVertex + 3].color = color;
    vertexBuffer.vertices[baseVertex + 3].normal = normal;
    vertexBuffer.vertices[baseVertex + 3].texCoord = vec2(0, 1);
    
    // Allocate 6 indices (2 triangles)
    uint baseIndex = atomicAdd(counter.indexCount, 6u);
    if (baseIndex + 5 >= MAX_INDICES) return;
    
    // Triangle 1
    indexBuffer.indices[baseIndex + 0] = baseVertex + 0;
    indexBuffer.indices[baseIndex + 1] = baseVertex + 1;
    indexBuffer.indices[baseIndex + 2] = baseVertex + 2;
    
    // Triangle 2
    indexBuffer.indices[baseIndex + 3] = baseVertex + 0;
    indexBuffer.indices[baseIndex + 4] = baseVertex + 2;
    indexBuffer.indices[baseIndex + 5] = baseVertex + 3;
}