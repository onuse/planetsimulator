#version 450

// Compute shader that generates a sphere mesh similar to CPU reference
// This is step 1: Get GPU mesh generation working with a simple sphere

layout(local_size_x = 64) in;

// CRITICAL: This must match the C++ Vertex struct in transvoxel_renderer.hpp!
// C++ struct order: position, normal, color, texCoord
// Pipeline expects these at locations 0, 1, 2, 3 respectively
struct Vertex {
    vec3 position;   // offset 0 - location 0
    vec3 normal;     // offset 12 - location 2 (but MUST BE SECOND in struct!)
    vec3 color;      // offset 24 - location 1 (but MUST BE THIRD in struct!)
    vec2 texCoord;   // offset 36 - location 3
};

layout(binding = 1, std430) writeonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

layout(binding = 2, std430) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

layout(binding = 3, std430) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
} counter;

// Configuration constants (no push constants for now)
const float PI = 3.14159265359;
const uint LATITUDE_DIVISIONS = 20;
const uint LONGITUDE_DIVISIONS = 40;
const float PLANET_RADIUS = 1000.0;

void main() {
    uint threadId = gl_GlobalInvocationID.x;
    
    // Only thread 0 does all the work to ensure proper mesh connectivity
    if (threadId != 0) return;
    
    // Use hardcoded parameters
    uint latDivisions = LATITUDE_DIVISIONS;
    uint lonDivisions = LONGITUDE_DIVISIONS;
    float planetRadius = PLANET_RADIUS;
    
    uint totalVertices = (latDivisions + 1) * (lonDivisions + 1);
    uint totalIndices = latDivisions * lonDivisions * 6; // 2 triangles per quad, 3 indices per triangle
    
    // Generate ALL vertices in a single thread
    for (uint lat = 0; lat <= latDivisions; lat++) {
        float theta = float(lat) * PI / float(latDivisions);
        float sinTheta = sin(theta);
        float cosTheta = cos(theta);
        
        for (uint lon = 0; lon <= lonDivisions; lon++) {
            float phi = float(lon) * 2.0 * PI / float(lonDivisions);
            float sinPhi = sin(phi);
            float cosPhi = cos(phi);
            
            // Calculate vertex index
            uint vertexIndex = lat * (lonDivisions + 1) + lon;
            
            // Position on unit sphere
            vec3 unitPos = vec3(
                sinTheta * cosPhi,
                cosTheta,
                sinTheta * sinPhi
            );
            
            // Multi-octave terrain generation for realistic features
            float continental = sin(phi * 2.0) * cos(theta * 1.5) * 0.7 +
                               sin(phi * 1.3 + 1.2) * cos(theta * 2.2 - 0.8) * 0.5 +
                               sin(phi * 3.1 - 0.5) * sin(theta * 1.8 + 1.0) * 0.3;
            
            float mountains = abs(sin(phi * 5.0) * cos(theta * 4.0)) * 0.3 +
                             abs(sin(phi * 8.0 + 0.7) * cos(theta * 6.0 - 0.3)) * 0.2;
            
            float detail = sin(phi * 15.0) * cos(theta * 12.0) * 0.1 +
                          sin(phi * 23.0 - 1.1) * cos(theta * 19.0 + 0.6) * 0.05;
            
            float elevation = continental * 80.0 + mountains * 40.0 + detail * 10.0;
            
            // Create distinct ocean basins
            if (continental < -0.2) {
                elevation = continental * 100.0 - 30.0; // Deep ocean
            }
            
            vec3 position = unitPos * (planetRadius + elevation);
            
            // Store vertex (must write fields in struct order!)
            vertexBuffer.vertices[vertexIndex].position = position;
            vertexBuffer.vertices[vertexIndex].normal = unitPos;  // Normal MUST be second field!
            
            // Realistic biome coloring
            vec3 color;
            float latitudeFactor = abs(cosTheta); // 1 at poles, 0 at equator
            
            if (elevation < -50.0) {
                color = vec3(0.02, 0.08, 0.2); // Deep ocean trench
            } else if (elevation < -20.0) {
                color = vec3(0.05, 0.15, 0.4); // Deep ocean
            } else if (elevation < -5.0) {
                color = vec3(0.1, 0.3, 0.65); // Ocean
            } else if (elevation < 0.0) {
                color = vec3(0.15, 0.45, 0.75); // Shallow water
            } else if (elevation < 3.0) {
                color = vec3(0.95, 0.9, 0.7); // Beach
            } else if (elevation < 25.0) {
                // Lowlands with latitude-based biomes
                if (latitudeFactor > 0.7) {
                    color = vec3(0.7, 0.75, 0.7); // Tundra
                } else if (latitudeFactor < 0.3) {
                    color = vec3(0.1, 0.35, 0.05); // Rainforest
                } else {
                    color = vec3(0.3, 0.65, 0.2); // Grassland
                }
            } else if (elevation < 50.0) {
                // Hills/forest
                if (latitudeFactor > 0.6) {
                    color = vec3(0.15, 0.3, 0.15); // Boreal forest
                } else {
                    color = vec3(0.2, 0.45, 0.1); // Deciduous forest
                }
            } else if (elevation < 70.0) {
                color = vec3(0.55, 0.45, 0.4); // Mountains
            } else if (elevation < 85.0) {
                color = vec3(0.65, 0.6, 0.55); // High mountains
            } else {
                color = vec3(0.98, 0.98, 1.0); // Snow caps
            }
            
            // Add variation to break up uniform colors
            float variation = fract(sin(phi * 31.4159 + theta * 27.1828) * 43758.5453) * 0.1 - 0.05;
            color = clamp(color + variation, 0.0, 1.0);
            
            vertexBuffer.vertices[vertexIndex].color = color;  // Color MUST be third field!
            vertexBuffer.vertices[vertexIndex].texCoord = vec2(
                float(lon) / float(lonDivisions),
                float(lat) / float(latDivisions)
            );
        }
    }
    
    // Only thread 0 generates ALL indices to avoid any potential issues
    if (threadId == 0) {
        uint idx = 0;
        for (uint ilat = 0; ilat < latDivisions; ilat++) {
            for (uint ilon = 0; ilon < lonDivisions; ilon++) {
                uint first = ilat * (lonDivisions + 1) + ilon;
                uint second = first + lonDivisions + 1;
                
                // First triangle
                indexBuffer.indices[idx++] = first;
                indexBuffer.indices[idx++] = second;
                indexBuffer.indices[idx++] = first + 1;
                
                // Second triangle  
                indexBuffer.indices[idx++] = second;
                indexBuffer.indices[idx++] = second + 1;
                indexBuffer.indices[idx++] = first + 1;
            }
        }
        
        counter.vertexCount = totalVertices;
        counter.indexCount = totalIndices;
    }
}