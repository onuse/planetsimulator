#version 450

// Fixed Marching Cubes implementation for mesh generation
// Simplified but working version

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Octree data structures
struct OctreeNode {
    vec4 centerAndSize;      // xyz = center, w = halfSize
    uvec4 childrenAndFlags;  // x = children offset, y = voxel offset, z = flags, w = reserved
};

struct Vertex {
    vec3 position;
    vec3 normal;
    vec3 color;
    vec2 texCoord;
};

// Buffers
layout(binding = 0, std430) readonly buffer OctreeBuffer {
    OctreeNode nodes[];
} octree;

layout(binding = 1, std430) readonly buffer VoxelBuffer {
    vec4 voxels[];
} voxelBuffer;

layout(binding = 2, std430) writeonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

layout(binding = 3, std430) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

layout(binding = 4, std430) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
} counter;

// Constants
const uint MAX_VERTICES = 3000000;
const uint MAX_INDICES = 9000000;
const float PLANET_RADIUS = 1000.0;
const float ISO_LEVEL = 0.0;

// Edge to vertex mapping for marching cubes
const ivec2 EDGE_VERTICES[12] = ivec2[12](
    ivec2(0, 1), ivec2(1, 2), ivec2(2, 3), ivec2(3, 0),
    ivec2(4, 5), ivec2(5, 6), ivec2(6, 7), ivec2(7, 4),
    ivec2(0, 4), ivec2(1, 5), ivec2(2, 6), ivec2(3, 7)
);

// Helper functions
vec3 getTerrainColor(vec3 pos) {
    float altitude = length(pos) - PLANET_RADIUS;
    
    if (altitude < -50.0) {
        return vec3(0.0, 0.2, 0.5); // Deep water
    } else if (altitude < 0.0) {
        return vec3(0.0, 0.4, 0.7); // Shallow water
    } else if (altitude < 50.0) {
        return vec3(0.9, 0.8, 0.6); // Beach
    } else if (altitude < 200.0) {
        return vec3(0.2, 0.6, 0.2); // Grass
    } else {
        return vec3(0.95, 0.95, 1.0); // Snow
    }
}

// Simplified triangle generation function
// For each cube configuration, generate triangles based on which edges cross the surface
void generateTriangles(uint cubeIndex, vec3 edgeVerts[12], uint material) {
    // Handle some common cases explicitly
    // This is a simplified version - full marching cubes would have all 256 cases
    
    if (cubeIndex == 0u || cubeIndex == 255u) {
        return; // All inside or all outside
    }
    
    // Reserve space for vertices
    uint baseIdx = atomicAdd(counter.vertexCount, 3u);
    if (baseIdx + 2u >= MAX_VERTICES) return;
    
    uint triIdx = atomicAdd(counter.indexCount, 3u);
    if (triIdx + 2u >= MAX_INDICES) return;
    
    // For simplicity, create a triangle from first 3 edge crossings found
    // This won't be correct but will at least generate visible geometry
    uint vertCount = 0u;
    vec3 triVerts[3];
    
    // Find edge crossings
    for (uint i = 0u; i < 12u && vertCount < 3u; i++) {
        uint v1 = uint(EDGE_VERTICES[i].x);
        uint v2 = uint(EDGE_VERTICES[i].y);
        
        bool v1Inside = (cubeIndex & (1u << v1)) != 0u;
        bool v2Inside = (cubeIndex & (1u << v2)) != 0u;
        
        if (v1Inside != v2Inside) {
            triVerts[vertCount] = edgeVerts[i];
            vertCount++;
        }
    }
    
    // If we found at least 3 vertices, create a triangle
    if (vertCount >= 3u) {
        for (uint i = 0u; i < 3u; i++) {
            vec3 pos = triVerts[i];
            vec3 normal = normalize(pos); // Simple normal for sphere
            
            vertexBuffer.vertices[baseIdx + i].position = pos;
            vertexBuffer.vertices[baseIdx + i].normal = normal;
            vertexBuffer.vertices[baseIdx + i].color = getTerrainColor(pos);
            vertexBuffer.vertices[baseIdx + i].texCoord = vec2(0, 0);
            
            indexBuffer.indices[triIdx + i] = baseIdx + i;
        }
    } else {
        // Rollback allocations if we couldn't create a triangle
        atomicAdd(counter.vertexCount, -3);
        atomicAdd(counter.indexCount, -3);
    }
}

vec3 getCornerPosition(vec3 center, float halfSize, uint corner) {
    vec3 offset = vec3(
        (corner & 1u) != 0u ? halfSize : -halfSize,
        (corner & 2u) != 0u ? halfSize : -halfSize,
        (corner & 4u) != 0u ? halfSize : -halfSize
    );
    return center + offset;
}

float sampleDensity(vec3 pos) {
    // Simple sphere SDF
    return length(pos) - PLANET_RADIUS;
}

bool isLeaf(OctreeNode node) {
    return (node.childrenAndFlags.z & 1u) != 0u;
}

uint getMaterial(OctreeNode node) {
    return (node.childrenAndFlags.z >> 8u) & 0xFFu;
}

vec3 interpolateEdge(vec3 p1, vec3 p2, float d1, float d2) {
    if (abs(d1 - d2) < 0.00001) return p1;
    float t = (ISO_LEVEL - d1) / (d2 - d1);
    return mix(p1, p2, clamp(t, 0.0, 1.0));
}

void main() {
    uvec3 voxelCoord = gl_GlobalInvocationID;
    
    // Simple grid traversal
    uint nodeIndex = voxelCoord.x + voxelCoord.y * 256u + voxelCoord.z * 65536u;
    
    if (nodeIndex >= octree.nodes.length()) {
        return;
    }
    
    OctreeNode node = octree.nodes[nodeIndex];
    
    if (!isLeaf(node)) {
        return;
    }
    
    vec3 center = node.centerAndSize.xyz;
    float halfSize = node.centerAndSize.w;
    uint material = getMaterial(node);
    
    if (material == 0u) {
        return; // Skip air
    }
    
    // Sample density at corners
    float densities[8];
    vec3 corners[8];
    
    for (uint i = 0u; i < 8u; i++) {
        corners[i] = getCornerPosition(center, halfSize, i);
        densities[i] = sampleDensity(corners[i]);
    }
    
    // Determine cube configuration
    uint cubeIndex = 0u;
    for (uint i = 0u; i < 8u; i++) {
        if (densities[i] < ISO_LEVEL) {
            cubeIndex |= (1u << i);
        }
    }
    
    if (cubeIndex == 0u || cubeIndex == 255u) {
        return;
    }
    
    // Calculate edge vertices
    vec3 edgeVerts[12];
    for (uint i = 0u; i < 12u; i++) {
        uint v1 = uint(EDGE_VERTICES[i].x);
        uint v2 = uint(EDGE_VERTICES[i].y);
        
        bool v1Inside = densities[v1] < ISO_LEVEL;
        bool v2Inside = densities[v2] < ISO_LEVEL;
        
        if (v1Inside != v2Inside) {
            edgeVerts[i] = interpolateEdge(corners[v1], corners[v2], 
                                          densities[v1], densities[v2]);
        }
    }
    
    // Generate triangles
    generateTriangles(cubeIndex, edgeVerts, material);
}