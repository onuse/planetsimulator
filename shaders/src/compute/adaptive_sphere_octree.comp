#version 450

// Adaptive sphere mesh generation with octree traversal
// Generates an icosphere and samples octree for materials/terrain

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Input uniforms
layout(binding = 0) uniform UBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec3 cameraPos;
    float planetRadius;
    vec3 planetCenter;
    float time;
    int highDetailLevel;  // Front hemisphere subdivision
    int lowDetailLevel;   // Back hemisphere subdivision
    int flipFrontBack;    // 0 or 1, flips front/back determination
    int maxVertices;
    int maxIndices;
} ubo;

// Octree data structures matching GPU upload
struct GPUNode {
    vec4 centerAndSize;      // xyz = center, w = halfSize
    uvec4 childrenAndFlags;  // x = children index, y = voxel index, z = flags, w = padding
};

struct GPUVoxel {
    vec4 colorAndDensity;    // xyz = color, w = density
    vec4 extra;              // x = materialID, y = temperature, z = pressure, w = reserved
};

// Octree buffers
layout(std430, binding = 1) readonly buffer OctreeNodes {
    GPUNode nodes[];
} octreeNodes;

layout(std430, binding = 2) readonly buffer OctreeVoxels {
    GPUVoxel voxels[];
} octreeVoxels;

// Output buffers
layout(std430, binding = 3) writeonly buffer VertexBuffer {
    float vertices[];  // Interleaved: pos(3), color(3), normal(3), uv(2) = 11 floats per vertex
} vertexBuffer;

layout(std430, binding = 4) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

// Atomic counters for output tracking
layout(std430, binding = 5) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
    uint frontFaceCount;
    uint backFaceCount;
} counters;

// Material IDs matching core/material_table.hpp
const uint MATERIAL_VACUUM = 0;   // Empty space
const uint MATERIAL_AIR = 1;      // Atmosphere
const uint MATERIAL_ROCK = 2;     // Generic rock
const uint MATERIAL_WATER = 3;    // Liquid water
const uint MATERIAL_SAND = 4;     // Desert/beach
const uint MATERIAL_SOIL = 5;     // Fertile earth
const uint MATERIAL_GRASS = 6;    // Vegetation
const uint MATERIAL_SNOW = 7;     // Snow/frost
const uint MATERIAL_ICE = 8;      // Solid ice

// Icosahedron base vertices
const float t = 1.618033988749895; // Golden ratio
const float s = sqrt(1.0 + t * t); // Normalization factor

const vec3 icosahedronVerts[12] = vec3[12](
    vec3(-1,  t,  0) / s,
    vec3( 1,  t,  0) / s,
    vec3(-1, -t,  0) / s,
    vec3( 1, -t,  0) / s,
    vec3( 0, -1,  t) / s,
    vec3( 0,  1,  t) / s,
    vec3( 0, -1, -t) / s,
    vec3( 0,  1, -t) / s,
    vec3( t,  0, -1) / s,
    vec3( t,  0,  1) / s,
    vec3(-t,  0, -1) / s,
    vec3(-t,  0,  1) / s
);

// Icosahedron faces (20 triangles)
const uvec3 icosahedronFaces[20] = uvec3[20](
    uvec3(0, 11, 5),  uvec3(0, 5, 1),   uvec3(0, 1, 7),   uvec3(0, 7, 10),  uvec3(0, 10, 11),
    uvec3(1, 5, 9),   uvec3(5, 11, 4),  uvec3(11, 10, 2), uvec3(10, 7, 6),  uvec3(7, 1, 8),
    uvec3(3, 9, 4),   uvec3(3, 4, 2),   uvec3(3, 2, 6),   uvec3(3, 6, 8),   uvec3(3, 8, 9),
    uvec3(4, 9, 5),   uvec3(2, 4, 11),  uvec3(6, 2, 10),  uvec3(8, 6, 7),   uvec3(9, 8, 1)
);

// Traverse octree to find voxel at world position
uint findVoxelAtPosition(vec3 worldPos) {
    // Start at root node
    uint nodeIndex = 0;
    
    // Traverse down the tree
    for (int depth = 0; depth < 20; depth++) { // Max depth safety
        GPUNode node = octreeNodes.nodes[nodeIndex];
        
        // Extract node data
        uint childrenIndex = node.childrenAndFlags.x;
        uint voxelIndex = node.childrenAndFlags.y;
        
        // Check if this is a leaf node (no children)
        bool isLeaf = (childrenIndex == 0xFFFFFFFF);
        
        if (isLeaf) {
            // Found a leaf node - determine which voxel in the 2x2x2 block
            vec3 center = node.centerAndSize.xyz;
            vec3 localPos = worldPos - center;
            
            // Calculate voxel offset within the 2x2x2 block (matching CPU implementation)
            uint voxelOffset = 0;
            if (localPos.x > 0) voxelOffset |= 1;
            if (localPos.y > 0) voxelOffset |= 2;
            if (localPos.z > 0) voxelOffset |= 4;
            
            // Return the specific voxel in the block
            if (voxelIndex != 0xFFFFFFFF) {
                return voxelIndex + voxelOffset;
            } else {
                return 0; // No voxel data
            }
        }
        
        // Determine which child octant contains the position
        vec3 center = node.centerAndSize.xyz;
        
        // Calculate child index based on position relative to center
        uint childIdx = 0;
        if (worldPos.x > center.x) childIdx |= 1;
        if (worldPos.y > center.y) childIdx |= 2;
        if (worldPos.z > center.z) childIdx |= 4;
        
        // Move to the appropriate child
        nodeIndex = childrenIndex + childIdx;
        
        // Safety check
        if (nodeIndex >= 100000) { // Arbitrary large number
            break;
        }
    }
    
    return 0; // Default voxel if traversal fails
}

// Get material properties from voxel
void getMaterialFromVoxel(uint voxelIdx, out vec3 color, out float displacement) {
    if (voxelIdx >= 100000 || voxelIdx == 0xFFFFFFFF) { // Safety check
        color = vec3(0.5, 0.5, 0.5);
        displacement = 0.0;
        return;
    }
    
    GPUVoxel voxel = octreeVoxels.voxels[voxelIdx];
    
    // Extract material ID from voxel data
    uint materialID = uint(voxel.extra.x);
    
    // Use the color from voxel (already computed on CPU side)
    color = voxel.colorAndDensity.xyz;
    
    // Map material ID to displacement (matching CPU implementation)
    switch(materialID) {
        case MATERIAL_VACUUM:
            displacement = 0.0;  // Empty space
            break;
        case MATERIAL_AIR:
            displacement = 0.0;  // Atmosphere - no displacement
            break;
        case MATERIAL_ROCK:
            displacement = 150.0;
            break;
        case MATERIAL_WATER:
            displacement = -100.0;
            break;
        case MATERIAL_SAND:
            displacement = 10.0;
            break;
        case MATERIAL_GRASS:
            displacement = 50.0;
            break;
        case MATERIAL_SNOW:
            displacement = 300.0;
            break;
        default:
            displacement = 0.0;
            break;
    }
    
    // Add some variation based on density
    float density = voxel.colorAndDensity.w;
    displacement += (density - 0.5) * 20.0;
}

// Helper function to add a vertex
uint addVertex(vec3 pos, vec3 color, vec3 normal, vec2 uv, uint vOffset) {
    uint idx = vOffset * 11;
    vertexBuffer.vertices[idx + 0] = pos.x;
    vertexBuffer.vertices[idx + 1] = pos.y;
    vertexBuffer.vertices[idx + 2] = pos.z;
    vertexBuffer.vertices[idx + 3] = color.r;
    vertexBuffer.vertices[idx + 4] = color.g;
    vertexBuffer.vertices[idx + 5] = color.b;
    vertexBuffer.vertices[idx + 6] = normal.x;
    vertexBuffer.vertices[idx + 7] = normal.y;
    vertexBuffer.vertices[idx + 8] = normal.z;
    vertexBuffer.vertices[idx + 9] = uv.x;
    vertexBuffer.vertices[idx + 10] = uv.y;
    return vOffset;
}

// Output a single triangle with octree sampling
void outputTriangle(vec3 v0, vec3 v1, vec3 v2, bool isFront) {
    // Add vertices
    uint i0 = atomicAdd(counters.vertexCount, 1);
    uint i1 = atomicAdd(counters.vertexCount, 1);
    uint i2 = atomicAdd(counters.vertexCount, 1);
    
    // Sample octree for each vertex
    vec3 col0, col1, col2;
    float disp0, disp1, disp2;
    
    // Convert normalized sphere positions to world space for octree lookup
    vec3 worldPos0 = v0 * ubo.planetRadius;
    vec3 worldPos1 = v1 * ubo.planetRadius;
    vec3 worldPos2 = v2 * ubo.planetRadius;
    
    // Find voxels and get materials
    uint voxel0 = findVoxelAtPosition(worldPos0);
    uint voxel1 = findVoxelAtPosition(worldPos1);
    uint voxel2 = findVoxelAtPosition(worldPos2);
    
    getMaterialFromVoxel(voxel0, col0, disp0);
    getMaterialFromVoxel(voxel1, col1, disp1);
    getMaterialFromVoxel(voxel2, col2, disp2);
    
    // Apply displacement to positions
    vec3 p0 = worldPos0 + v0 * disp0;
    vec3 p1 = worldPos1 + v1 * disp1;
    vec3 p2 = worldPos2 + v2 * disp2;
    
    // Calculate face normal for proper shading
    vec3 faceNormal = normalize(cross(p1 - p0, p2 - p0));
    
    // Add subtle front/back indication for debugging
    float debugTint = isFront ? 1.05 : 0.95;
    
    // Use face normal for all vertices (flat shading for now)
    addVertex(p0, col0 * debugTint, faceNormal, vec2(0.5 + atan(v0.z, v0.x) / (2.0 * 3.14159265359), 0.5 + asin(v0.y) / 3.14159265359), i0);
    addVertex(p1, col1 * debugTint, faceNormal, vec2(0.5 + atan(v1.z, v1.x) / (2.0 * 3.14159265359), 0.5 + asin(v1.y) / 3.14159265359), i1);
    addVertex(p2, col2 * debugTint, faceNormal, vec2(0.5 + atan(v2.z, v2.x) / (2.0 * 3.14159265359), 0.5 + asin(v2.y) / 3.14159265359), i2);
    
    // Add indices
    uint baseIdx = atomicAdd(counters.indexCount, 3);
    indexBuffer.indices[baseIdx + 0] = i0;
    indexBuffer.indices[baseIdx + 1] = i1;
    indexBuffer.indices[baseIdx + 2] = i2;
    
    if (isFront) {
        atomicAdd(counters.frontFaceCount, 1);
    } else {
        atomicAdd(counters.backFaceCount, 1);
    }
}

// Subdivide a triangle iteratively
void subdivideTriangle(vec3 v0, vec3 v1, vec3 v2, int level) {
    // Clamp level to prevent stack overflow
    level = min(level, 5);
    
    // Stack for iterative subdivision
    vec3 stack[256*3];
    int levels[256];
    int stackPtr = 0;
    
    // Push initial triangle
    stack[0] = v0;
    stack[1] = v1;
    stack[2] = v2;
    levels[0] = level;
    stackPtr = 1;
    
    while (stackPtr > 0) {
        // Pop triangle
        stackPtr--;
        vec3 t0 = stack[stackPtr * 3 + 0];
        vec3 t1 = stack[stackPtr * 3 + 1];
        vec3 t2 = stack[stackPtr * 3 + 2];
        int curLevel = levels[stackPtr];
        
        if (curLevel == 0) {
            // Output the triangle
            vec3 center = normalize((t0 + t1 + t2) / 3.0);
            vec3 toCam = normalize(ubo.cameraPos - center * ubo.planetRadius);
            float dotProduct = dot(center, toCam);
            bool isFront = (dotProduct > 0.0) != (ubo.flipFrontBack != 0);
            outputTriangle(t0, t1, t2, isFront);
        } else if (stackPtr < 250) {
            // Subdivide: create midpoints
            vec3 m0 = normalize((t0 + t1) * 0.5);
            vec3 m1 = normalize((t1 + t2) * 0.5);
            vec3 m2 = normalize((t2 + t0) * 0.5);
            
            // Push 4 triangles onto stack
            int newLevel = curLevel - 1;
            
            // Triangle 1: v0, m0, m2
            stack[stackPtr * 3 + 0] = t0;
            stack[stackPtr * 3 + 1] = m0;
            stack[stackPtr * 3 + 2] = m2;
            levels[stackPtr] = newLevel;
            stackPtr++;
            
            // Triangle 2: m0, v1, m1
            stack[stackPtr * 3 + 0] = m0;
            stack[stackPtr * 3 + 1] = t1;
            stack[stackPtr * 3 + 2] = m1;
            levels[stackPtr] = newLevel;
            stackPtr++;
            
            // Triangle 3: m2, m1, v2
            stack[stackPtr * 3 + 0] = m2;
            stack[stackPtr * 3 + 1] = m1;
            stack[stackPtr * 3 + 2] = t2;
            levels[stackPtr] = newLevel;
            stackPtr++;
            
            // Triangle 4: m0, m1, m2
            stack[stackPtr * 3 + 0] = m0;
            stack[stackPtr * 3 + 1] = m1;
            stack[stackPtr * 3 + 2] = m2;
            levels[stackPtr] = newLevel;
            stackPtr++;
        }
    }
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    
    // Each thread processes one base triangle
    if (gid < 20) {
        uvec3 face = icosahedronFaces[gid];
        vec3 v0 = icosahedronVerts[face.x];
        vec3 v1 = icosahedronVerts[face.y];
        vec3 v2 = icosahedronVerts[face.z];
        
        // For adaptive LOD, determine base triangle's subdivision level
        vec3 center = normalize((v0 + v1 + v2) / 3.0);
        vec3 toCam = normalize(ubo.cameraPos - center * ubo.planetRadius);
        float dotProduct = dot(center, toCam);
        bool baseFront = (dotProduct > 0.0) != (ubo.flipFrontBack != 0);
        
        // Use adaptive subdivision based on base triangle facing
        int subdivLevel = baseFront ? ubo.highDetailLevel : ubo.lowDetailLevel;
        
        // Subdivide this triangle
        subdivideTriangle(v0, v1, v2, subdivLevel);
    }
}