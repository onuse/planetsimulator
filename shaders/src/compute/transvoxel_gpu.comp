#version 450

// GPU Transvoxel implementation for voxel-to-mesh conversion
// Processes octree nodes in parallel to generate triangle meshes

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// ==================== Input Uniforms ====================
layout(binding = 0) uniform UBO {
    mat4 viewMatrix;
    mat4 projMatrix;
    vec3 cameraPos;
    float planetRadius;
    vec3 planetCenter;
    float time;
    float voxelSize;        // Size of voxels at current LOD
    int gridSize;           // Grid resolution (e.g., 32x32x32)
    int maxVertices;
    int maxIndices;
} ubo;

// ==================== Octree Data Structures ====================
struct GPUNode {
    vec4 centerAndSize;      // xyz = center, w = halfSize
    uvec4 childrenAndFlags;  // x = children index, y = voxel index, z = flags, w = padding
};

struct GPUVoxel {
    vec4 colorAndDensity;    // xyz = color, w = density
    vec4 extra;              // x = materialID, y = temperature, z = pressure, w = reserved
};

// Octree buffers
layout(std430, binding = 1) readonly buffer OctreeNodes {
    GPUNode nodes[];
} octreeNodes;

layout(std430, binding = 2) readonly buffer OctreeVoxels {
    GPUVoxel voxels[];
} octreeVoxels;

// ==================== Output Buffers ====================
layout(std430, binding = 3) writeonly buffer VertexBuffer {
    float vertices[];  // Interleaved: pos(3), color(3), normal(3), uv(2) = 11 floats per vertex
} vertexBuffer;

layout(std430, binding = 4) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

layout(std430, binding = 5) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
    uint processedCells;
    uint generatedTriangles;
} counters;

// ==================== Transvoxel Tables ====================
// Marching cubes case table - determines which edges are intersected
const int edgeTable[256] = int[256](
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    // ... (full 256 entry table would go here)
    // For brevity, using simplified version
    0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
    0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
    0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
    0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
    0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
    0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
    0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
    0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
    0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
    0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
    0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
    0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
    0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
    0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
    0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
    0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
    0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
    0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
    0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
    0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
    0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
    0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
    0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
    0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
    0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
    0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
    0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
    0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
    0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
    0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
    0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
    0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
);

// Edge vertex positions (12 edges on a cube)
const vec3 edgeVertices[12][2] = vec3[12][2](
    vec3[2](vec3(0,0,0), vec3(1,0,0)), // Edge 0
    vec3[2](vec3(1,0,0), vec3(1,1,0)), // Edge 1
    vec3[2](vec3(1,1,0), vec3(0,1,0)), // Edge 2
    vec3[2](vec3(0,1,0), vec3(0,0,0)), // Edge 3
    vec3[2](vec3(0,0,1), vec3(1,0,1)), // Edge 4
    vec3[2](vec3(1,0,1), vec3(1,1,1)), // Edge 5
    vec3[2](vec3(1,1,1), vec3(0,1,1)), // Edge 6
    vec3[2](vec3(0,1,1), vec3(0,0,1)), // Edge 7
    vec3[2](vec3(0,0,0), vec3(0,0,1)), // Edge 8
    vec3[2](vec3(1,0,0), vec3(1,0,1)), // Edge 9
    vec3[2](vec3(1,1,0), vec3(1,1,1)), // Edge 10
    vec3[2](vec3(0,1,0), vec3(0,1,1))  // Edge 11
);

// ==================== Helper Functions ====================

// Sample density from octree at world position
float sampleDensity(vec3 worldPos) {
    // Start at root node
    uint nodeIndex = 0;
    
    // Traverse octree to find voxel
    for (int depth = 0; depth < 20; depth++) {
        GPUNode node = octreeNodes.nodes[nodeIndex];
        
        uint childrenIndex = node.childrenAndFlags.x;
        uint voxelIndex = node.childrenAndFlags.y;
        
        // Check if leaf
        if (childrenIndex == 0xFFFFFFFF) {
            if (voxelIndex != 0xFFFFFFFF && voxelIndex < 100000) {
                // Sample from voxel block
                vec3 localPos = worldPos - node.centerAndSize.xyz;
                uint voxelOffset = 0;
                if (localPos.x > 0) voxelOffset |= 1;
                if (localPos.y > 0) voxelOffset |= 2;
                if (localPos.z > 0) voxelOffset |= 4;
                
                GPUVoxel voxel = octreeVoxels.voxels[voxelIndex + voxelOffset];
                
                // Return density (0 = empty, 1 = solid)
                // We determine solid/empty based on distance from planet surface
                float distFromCenter = length(worldPos);
                float surfaceDist = distFromCenter - ubo.planetRadius;
                
                // Simple threshold: negative = inside planet (solid), positive = outside (empty)
                return surfaceDist < 0.0 ? 1.0 : 0.0;
            }
            return 0.0; // Empty if no voxel data
        }
        
        // Determine child octant
        vec3 center = node.centerAndSize.xyz;
        uint childIdx = 0;
        if (worldPos.x > center.x) childIdx |= 1;
        if (worldPos.y > center.y) childIdx |= 2;
        if (worldPos.z > center.z) childIdx |= 4;
        
        nodeIndex = childrenIndex + childIdx;
        if (nodeIndex >= 100000) break; // Safety
    }
    
    return 0.0;
}

// Get material color from octree
vec3 getMaterialColor(vec3 worldPos) {
    // Simplified for now - sample from octree similar to density
    // In full implementation, would traverse octree and get material color
    
    float height = length(worldPos) - ubo.planetRadius;
    
    // Simple height-based coloring
    if (height < -1000.0) {
        return vec3(0.5, 0.3, 0.2); // Deep rock (brown)
    } else if (height < -100.0) {
        return vec3(0.6, 0.4, 0.3); // Rock
    } else if (height < 0.0) {
        return vec3(0.2, 0.5, 0.2); // Grass
    } else if (height < 100.0) {
        return vec3(0.8, 0.8, 0.6); // Sand
    } else {
        return vec3(1.0, 1.0, 1.0); // Snow
    }
}

// Linear interpolation for vertex position
vec3 vertexInterp(vec3 p1, vec3 p2, float v1, float v2, float isolevel) {
    if (abs(isolevel - v1) < 0.00001)
        return p1;
    if (abs(isolevel - v2) < 0.00001)
        return p2;
    if (abs(v1 - v2) < 0.00001)
        return p1;
    
    float mu = (isolevel - v1) / (v2 - v1);
    return p1 + mu * (p2 - p1);
}

// ==================== Main Compute Function ====================
void main() {
    // Get cell coordinates in the grid
    uvec3 cellCoord = gl_GlobalInvocationID.xyz;
    
    // Check bounds
    if (cellCoord.x >= ubo.gridSize || cellCoord.y >= ubo.gridSize || cellCoord.z >= ubo.gridSize) {
        return;
    }
    
    // Calculate world position of this cell
    vec3 cellWorldPos = ubo.planetCenter + 
                       (vec3(cellCoord) - vec3(ubo.gridSize/2)) * ubo.voxelSize;
    
    // Sample density at 8 corners of the cell
    float densities[8];
    vec3 positions[8];
    
    for (int i = 0; i < 8; i++) {
        vec3 offset = vec3(
            (i & 1) ? ubo.voxelSize : 0,
            (i & 2) ? ubo.voxelSize : 0,
            (i & 4) ? ubo.voxelSize : 0
        );
        positions[i] = cellWorldPos + offset;
        densities[i] = sampleDensity(positions[i]);
    }
    
    // Determine marching cubes case
    int cubeIndex = 0;
    float isolevel = 0.5; // Threshold between empty and solid
    
    if (densities[0] > isolevel) cubeIndex |= 1;
    if (densities[1] > isolevel) cubeIndex |= 2;
    if (densities[2] > isolevel) cubeIndex |= 4;
    if (densities[3] > isolevel) cubeIndex |= 8;
    if (densities[4] > isolevel) cubeIndex |= 16;
    if (densities[5] > isolevel) cubeIndex |= 32;
    if (densities[6] > isolevel) cubeIndex |= 64;
    if (densities[7] > isolevel) cubeIndex |= 128;
    
    // Skip if cell is entirely inside or outside
    if (cubeIndex == 0 || cubeIndex == 255) {
        return;
    }
    
    // Get edge flags
    int edges = edgeTable[cubeIndex];
    
    // Calculate vertex positions on edges
    vec3 vertList[12];
    
    if ((edges & 1) != 0)
        vertList[0] = vertexInterp(positions[0], positions[1], densities[0], densities[1], isolevel);
    if ((edges & 2) != 0)
        vertList[1] = vertexInterp(positions[1], positions[2], densities[1], densities[2], isolevel);
    if ((edges & 4) != 0)
        vertList[2] = vertexInterp(positions[2], positions[3], densities[2], densities[3], isolevel);
    if ((edges & 8) != 0)
        vertList[3] = vertexInterp(positions[3], positions[0], densities[3], densities[0], isolevel);
    if ((edges & 16) != 0)
        vertList[4] = vertexInterp(positions[4], positions[5], densities[4], densities[5], isolevel);
    if ((edges & 32) != 0)
        vertList[5] = vertexInterp(positions[5], positions[6], densities[5], densities[6], isolevel);
    if ((edges & 64) != 0)
        vertList[6] = vertexInterp(positions[6], positions[7], densities[6], densities[7], isolevel);
    if ((edges & 128) != 0)
        vertList[7] = vertexInterp(positions[7], positions[4], densities[7], densities[4], isolevel);
    if ((edges & 256) != 0)
        vertList[8] = vertexInterp(positions[0], positions[4], densities[0], densities[4], isolevel);
    if ((edges & 512) != 0)
        vertList[9] = vertexInterp(positions[1], positions[5], densities[1], densities[5], isolevel);
    if ((edges & 1024) != 0)
        vertList[10] = vertexInterp(positions[2], positions[6], densities[2], densities[6], isolevel);
    if ((edges & 2048) != 0)
        vertList[11] = vertexInterp(positions[3], positions[7], densities[3], densities[7], isolevel);
    
    // Generate triangles (simplified - would use full triangle table in production)
    // For now, just create a simple triangle if any edges are active
    if (edges != 0) {
        // Reserve vertex indices
        uint baseVertex = atomicAdd(counters.vertexCount, 3);
        uint baseIndex = atomicAdd(counters.indexCount, 3);
        
        // Safety check
        if (baseVertex + 3 > ubo.maxVertices || baseIndex + 3 > ubo.maxIndices) {
            return;
        }
        
        // Create a simple triangle from first 3 active edge vertices
        vec3 v0 = vertList[0];
        vec3 v1 = vertList[1]; 
        vec3 v2 = vertList[2];
        
        // Calculate normal
        vec3 normal = normalize(cross(v1 - v0, v2 - v0));
        
        // Get material colors
        vec3 color = getMaterialColor(cellWorldPos + vec3(ubo.voxelSize * 0.5));
        
        // Write vertices (interleaved format)
        uint vIdx = baseVertex * 11;
        
        // Vertex 0
        vertexBuffer.vertices[vIdx + 0] = v0.x;
        vertexBuffer.vertices[vIdx + 1] = v0.y;
        vertexBuffer.vertices[vIdx + 2] = v0.z;
        vertexBuffer.vertices[vIdx + 3] = color.r;
        vertexBuffer.vertices[vIdx + 4] = color.g;
        vertexBuffer.vertices[vIdx + 5] = color.b;
        vertexBuffer.vertices[vIdx + 6] = normal.x;
        vertexBuffer.vertices[vIdx + 7] = normal.y;
        vertexBuffer.vertices[vIdx + 8] = normal.z;
        vertexBuffer.vertices[vIdx + 9] = 0.0;  // UV.x
        vertexBuffer.vertices[vIdx + 10] = 0.0; // UV.y
        
        // Vertex 1
        vIdx = (baseVertex + 1) * 11;
        vertexBuffer.vertices[vIdx + 0] = v1.x;
        vertexBuffer.vertices[vIdx + 1] = v1.y;
        vertexBuffer.vertices[vIdx + 2] = v1.z;
        vertexBuffer.vertices[vIdx + 3] = color.r;
        vertexBuffer.vertices[vIdx + 4] = color.g;
        vertexBuffer.vertices[vIdx + 5] = color.b;
        vertexBuffer.vertices[vIdx + 6] = normal.x;
        vertexBuffer.vertices[vIdx + 7] = normal.y;
        vertexBuffer.vertices[vIdx + 8] = normal.z;
        vertexBuffer.vertices[vIdx + 9] = 0.0;
        vertexBuffer.vertices[vIdx + 10] = 0.0;
        
        // Vertex 2
        vIdx = (baseVertex + 2) * 11;
        vertexBuffer.vertices[vIdx + 0] = v2.x;
        vertexBuffer.vertices[vIdx + 1] = v2.y;
        vertexBuffer.vertices[vIdx + 2] = v2.z;
        vertexBuffer.vertices[vIdx + 3] = color.r;
        vertexBuffer.vertices[vIdx + 4] = color.g;
        vertexBuffer.vertices[vIdx + 5] = color.b;
        vertexBuffer.vertices[vIdx + 6] = normal.x;
        vertexBuffer.vertices[vIdx + 7] = normal.y;
        vertexBuffer.vertices[vIdx + 8] = normal.z;
        vertexBuffer.vertices[vIdx + 9] = 0.0;
        vertexBuffer.vertices[vIdx + 10] = 0.0;
        
        // Write indices
        indexBuffer.indices[baseIndex + 0] = baseVertex;
        indexBuffer.indices[baseIndex + 1] = baseVertex + 1;
        indexBuffer.indices[baseIndex + 2] = baseVertex + 2;
        
        // Update counters
        atomicAdd(counters.processedCells, 1);
        atomicAdd(counters.generatedTriangles, 1);
    }
}