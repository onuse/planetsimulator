#version 450

// Ultra simple sphere generator - single thread does everything
layout(local_size_x = 1) in;

struct Vertex {
    vec3 position;
    vec3 normal;     // normal MUST be second to match C++ struct
    vec3 color;      // color MUST be third to match C++ struct
    vec2 texCoord;
};

// Dummy binding 0 for octree (not used but expected by pipeline)
layout(binding = 0, std430) readonly buffer DummyBuffer {
    uint dummy[];
} dummyBuffer;

layout(binding = 1, std430) writeonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

layout(binding = 2, std430) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

layout(binding = 3, std430) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
} counter;

const float PI = 3.14159265359;

void main() {
    // Only thread 0 does work
    if (gl_GlobalInvocationID.x != 0) return;
    
    const uint LATS = 16;  // Reduced for simpler sphere
    const uint LONS = 32;
    const float RADIUS = 1000.0;
    
    uint vertIdx = 0;
    
    // Generate vertices
    for (uint lat = 0; lat <= LATS; lat++) {
        float theta = float(lat) * PI / float(LATS);
        float sinTheta = sin(theta);
        float cosTheta = cos(theta);
        
        for (uint lon = 0; lon <= LONS; lon++) {
            float phi = float(lon) * 2.0 * PI / float(LONS);
            float sinPhi = sin(phi);
            float cosPhi = cos(phi);
            
            vec3 pos = RADIUS * vec3(
                sinTheta * cosPhi,
                cosTheta,
                sinTheta * sinPhi
            );
            
            vertexBuffer.vertices[vertIdx].position = pos;
            vertexBuffer.vertices[vertIdx].normal = normalize(pos);
            
            // Simple coloring
            float h = pos.y / RADIUS;
            if (h < -0.2) {
                vertexBuffer.vertices[vertIdx].color = vec3(0.1, 0.3, 0.6); // Deep blue
            } else if (h < 0.0) {
                vertexBuffer.vertices[vertIdx].color = vec3(0.2, 0.5, 0.8); // Blue
            } else if (h < 0.3) {
                vertexBuffer.vertices[vertIdx].color = vec3(0.3, 0.7, 0.3); // Green
            } else {
                vertexBuffer.vertices[vertIdx].color = vec3(0.9, 0.9, 0.9); // White
            }
            
            vertexBuffer.vertices[vertIdx].texCoord = vec2(
                float(lon) / float(LONS),
                float(lat) / float(LATS)
            );
            
            vertIdx++;
        }
    }
    
    counter.vertexCount = vertIdx;
    
    // Generate indices
    uint idxCount = 0;
    for (uint lat = 0; lat < LATS; lat++) {
        for (uint lon = 0; lon < LONS; lon++) {
            uint curr = lat * (LONS + 1) + lon;
            uint next = curr + LONS + 1;
            
            // Triangle 1
            indexBuffer.indices[idxCount++] = curr;
            indexBuffer.indices[idxCount++] = next;
            indexBuffer.indices[idxCount++] = curr + 1;
            
            // Triangle 2
            indexBuffer.indices[idxCount++] = curr + 1;
            indexBuffer.indices[idxCount++] = next;
            indexBuffer.indices[idxCount++] = next + 1;
        }
    }
    
    counter.indexCount = idxCount;
}