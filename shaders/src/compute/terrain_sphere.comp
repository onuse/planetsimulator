#version 450

// Sphere generator with realistic terrain features
layout(local_size_x = 1) in;

struct Vertex {
    vec3 position;
    vec3 normal;     // normal MUST be second to match C++ struct
    vec3 color;      // color MUST be third to match C++ struct
    vec2 texCoord;
};

// Dummy binding 0 for octree (not used but expected by pipeline)
layout(binding = 0, std430) readonly buffer DummyBuffer {
    uint dummy[];
} dummyBuffer;

layout(binding = 1, std430) writeonly buffer VertexBuffer {
    Vertex vertices[];
} vertexBuffer;

layout(binding = 2, std430) writeonly buffer IndexBuffer {
    uint indices[];
} indexBuffer;

layout(binding = 3, std430) buffer CounterBuffer {
    uint vertexCount;
    uint indexCount;
} counter;

const float PI = 3.14159265359;
const uint LATS = 32;  // More detail for terrain
const uint LONS = 64;
const float RADIUS = 1000.0;

// Simple noise function
float noise(float x, float y) {
    return sin(x * 12.9898 + y * 78.233) * 43758.5453;
}

// Multi-octave noise for terrain
float terrainHeight(float theta, float phi) {
    // Continental plates - large scale features
    float continental = sin(phi * 2.0) * cos(theta * 1.5) * 0.7 +
                       sin(phi * 1.3 + 1.2) * cos(theta * 2.2 - 0.8) * 0.5 +
                       sin(phi * 3.1 - 0.5) * sin(theta * 1.8 + 1.0) * 0.3;
    
    // Mountain ranges
    float mountains = abs(sin(phi * 5.0) * cos(theta * 4.0)) * 0.3 +
                     abs(sin(phi * 8.0 + 0.7) * cos(theta * 6.0 - 0.3)) * 0.2;
    
    // Small scale detail
    float detail = sin(phi * 15.0) * cos(theta * 12.0) * 0.1 +
                   sin(phi * 23.0 - 1.1) * cos(theta * 19.0 + 0.6) * 0.05;
    
    // Combine scales
    float height = continental * 80.0 + mountains * 40.0 + detail * 10.0;
    
    // Create distinct ocean basins
    if (continental < -0.2) {
        height = continental * 100.0 - 30.0; // Deep ocean
    }
    
    return height;
}

void main() {
    if (gl_GlobalInvocationID.x != 0) return;
    
    uint vertIdx = 0;
    
    // Generate vertices with terrain
    for (uint lat = 0; lat <= LATS; lat++) {
        float theta = float(lat) * PI / float(LATS);
        float sinTheta = sin(theta);
        float cosTheta = cos(theta);
        
        for (uint lon = 0; lon <= LONS; lon++) {
            float phi = float(lon) * 2.0 * PI / float(LONS);
            float sinPhi = sin(phi);
            float cosPhi = cos(phi);
            
            // Calculate elevation
            float elevation = terrainHeight(theta, phi);
            
            // Unit sphere position
            vec3 unitPos = vec3(
                sinTheta * cosPhi,
                cosTheta,
                sinTheta * sinPhi
            );
            
            // Apply elevation
            vec3 pos = unitPos * (RADIUS + elevation);
            
            vertexBuffer.vertices[vertIdx].position = pos;
            vertexBuffer.vertices[vertIdx].normal = normalize(unitPos);
            
            // Distinct biome colors based on elevation and latitude
            vec3 color;
            float latitudeFactor = abs(cosTheta); // 1 at poles, 0 at equator
            
            if (elevation < -50.0) {
                // Deep ocean trench - very dark blue
                color = vec3(0.02, 0.08, 0.2);
            } else if (elevation < -20.0) {
                // Deep ocean - dark blue
                color = vec3(0.05, 0.15, 0.4);
            } else if (elevation < -5.0) {
                // Ocean - blue
                color = vec3(0.1, 0.3, 0.65);
            } else if (elevation < 0.0) {
                // Shallow water - lighter blue
                color = vec3(0.15, 0.45, 0.75);
            } else if (elevation < 3.0) {
                // Beach - sand
                color = vec3(0.95, 0.9, 0.7);
            } else if (elevation < 25.0) {
                // Lowlands
                if (latitudeFactor > 0.7) {
                    // Tundra near poles
                    color = vec3(0.7, 0.75, 0.7);
                } else if (latitudeFactor < 0.3) {
                    // Tropical rainforest near equator
                    color = vec3(0.1, 0.35, 0.05);
                } else {
                    // Temperate grassland
                    color = vec3(0.3, 0.65, 0.2);
                }
            } else if (elevation < 50.0) {
                // Hills/forest
                if (latitudeFactor > 0.6) {
                    // Boreal forest
                    color = vec3(0.15, 0.3, 0.15);
                } else {
                    // Deciduous forest
                    color = vec3(0.2, 0.45, 0.1);
                }
            } else if (elevation < 70.0) {
                // Mountains - rocky
                color = vec3(0.55, 0.45, 0.4);
            } else if (elevation < 85.0) {
                // High mountains - gray rock
                color = vec3(0.65, 0.6, 0.55);
            } else {
                // Snow caps
                color = vec3(0.98, 0.98, 1.0);
            }
            
            // Add slight variation to break up uniform colors
            float variation = fract(sin(phi * 31.4159 + theta * 27.1828) * 43758.5453) * 0.1 - 0.05;
            color = clamp(color + variation, 0.0, 1.0);
            
            vertexBuffer.vertices[vertIdx].color = color;
            vertexBuffer.vertices[vertIdx].texCoord = vec2(
                float(lon) / float(LONS),
                float(lat) / float(LATS)
            );
            
            vertIdx++;
        }
    }
    
    counter.vertexCount = vertIdx;
    
    // Generate indices
    uint idxCount = 0;
    for (uint lat = 0; lat < LATS; lat++) {
        for (uint lon = 0; lon < LONS; lon++) {
            uint curr = lat * (LONS + 1) + lon;
            uint next = curr + LONS + 1;
            
            indexBuffer.indices[idxCount++] = curr;
            indexBuffer.indices[idxCount++] = next;
            indexBuffer.indices[idxCount++] = curr + 1;
            
            indexBuffer.indices[idxCount++] = curr + 1;
            indexBuffer.indices[idxCount++] = next;
            indexBuffer.indices[idxCount++] = next + 1;
        }
    }
    
    counter.indexCount = idxCount;
}